[%- start_year = '2015' -%]
[% MACRO see(method) BLOCK -%]
This behaviour can be altered with the method L</[% method %]>
[%- END -%]
[%- MACRO since(version) BLOCK -%]
This method was added in version [% version %] of the module.
[%- END -%]
[%- MACRO fsince(version) BLOCK -%]
This function was added in version [% version %] of the module.
[%- END -%]
[%- MACRO bsince(version) BLOCK -%]
This behaviour was added in version [% version %] of the module.
[%- END -%]
[%- MACRO handler_undef BLOCK -%]

If your handler returns the undefined value, L</run> prints a warning
L</Undefined value from user routine>, halts further processing of the
input, and returns the undefined value.

[%- END %]
[%- MACRO handler_common(handler) BLOCK -%]
=over

=item * Calling convention

The [% handler %] routine is passed a single argument and is expected
to return a single argument, the JSON to output. It is called in
scalar context. In other words, the call looks like the following:

     $json = &{$jc->{[% handler %]}} ($item);

To pass or return multiple values via the C<[% handler %]> callback,
use a closure. See the discussion at L</obj> for an example.

=item * Returning undef halts processing

[% handler_undef %]

=item * Delete the handler with any false value

To remove the handler, simply call the function without an argument,

    $jc->[% handler %] ();

or with a false argument:

    $jc->[% handler %] (0);

The behaviour then reverts to the default.

=item * Checking the output JSON

The JSON output by your handler may be checked for validity by
switching on validation using L</validate>. If you do not use this,
and your return value happens to contain invalid UTF-8, you may see
the error L</Invalid UTF-8 from user routine>. Please see L</UTF-8
validation of user-supplied JSON> for more about this error.

=item * Exception handling

Exceptions (C<die>) thrown within C<[% handler %]> callbacks are not
caught by L</run> but passed through to the parent. Please see the
discussion at L</obj> for an example.

=back

[%- END -%]
[%- MACRO example(file) BLOCK %]
[%- pl = "examples/" _ file _ ".pl" -%]
[%- out = "examples/" _ file _ "-out.txt" -%]
[% INCLUDE $pl | xtidy %]

produces output

[% INCLUDE $out | xtidy %]

(This example is included as L<F<[% pl %]>|https://fastapi.metacpan.org/source/BKB/JSON-Create-[% version %]/[% pl %]> in the distribution.)
[% END %]
=encoding UTF-8

=head1 NAME

JSON::Create - serialize data to JSON

=head1 SYNOPSIS

[% example('synopsis') %]

=head1 VERSION

This document describes JSON::Create version [% version %],
corresponding to L<git commit [% commit.commit %]|[% info.repo
%]/commit/[% commit.commit %]> at [% commit.date %].

=head1 DESCRIPTION

JSON::Create encodes Perl variables into JSON. The basic routine
L</create_json> gives common defaults. The stricter version
L</create_json_strict> accepts only unambiguous inputs. For more
customization, an object created with L</new> and run with L</run>
allows specifying behaviour in more detail.

JSON::Create handles no string encoding except UTF-8. It supports
serialization of objects via user-defined callbacks. Its companion
module L<JSON::Parse> parsing JSON into Perl.

Errors in processing result in a warning and an undefined return
value. [% see('fatal_errors') %].

=head1 FUNCTIONS

=head2 create_json

    my $json = create_json (\%hash);

This converts a hash reference, array reference, or scalar into
JSON. The return value is the output JSON as a string.

Details of the conversion of each type are given in
L</CONVERSIONS>.

=head2 create_json_strict

    my $json = create_json_strict (\%hash);

This is the same as L</create_json>, except that it rejects ambiguous
inputs. See L</strict> for details.

[% fsince('0.20') %]

=head1 CONVERSIONS

This section details what conversions are applied to the various
inputs to produce outputs.

=head2 Hashes

JSON::Create turns associative arrays into JSON objects. The keys are
written into JSON as strings, with control characters escaped. The
order of the keys is as they are supplied by Perl.

[% example('hash') %]

Nested hashes are recursively followed:

[% example('nested-hash') %]

=head2 Arrays

Arrays are converted to JSON arrays. The order of elements of the
array is left unchanged.

[% example('array') %]

Nested arrays are recursively followed:

[% example('nested-array') %]

Nested hashes and arrays are converted similarly:

[% example('nested') %]

=head2 Scalars

Non-reference Perl scalars are converted to JSON strings or numbers,
depending on what Perl thinks they contain.

=head3 Strings

As far as possible, strings are written as they are to the JSON. 

JSON is Unicode, so all output is checked for Unicode
validity. Further, this module insists on UTF-8. (See L</Input strings
must be UTF-8>.) Invalid UTF-8 within input strings produces the error
L</Invalid UTF-8> and the undefined value is returned. [%
see('replace_bad_utf8') %]. (For full details of the corner cases, see
L</UNICODE HANDLING>.)

Some whitespace and control characters must be also escaped for the
output to be valid JSON. (See L</RFC 7159>.) 

In addition to this, L</create_json_strict> or the L</strict> option
reject inputs containing non-ASCII bytes (bytes with values of from
128 to 255) which are not marked as character strings.

=head4 Control characters and whitespace

To form valid JSON, bytes of value less than 0x20 in a Perl string
must be converted into JSON escapes, either the whitespace escapes \b
(backspace) \r, \t, \n, and \f, or the form \u0001 for other control
characters. Further, the backslash must be written as C<\\> and double
quotes must be written as C<\">.

This example demonstrates some of the necessary escaping:

[% example('weirdstring') %]

=head4 U+2028 and U+2029 (JavaScript clashes)

    my $out = create_json (["\x{2028}"]);
    # $out = '["\u2028"]'

Although it is not required by the JSON standard, JSON::Create by
default escapes Unicode code points U+2028 and U+2029 as C<\u2028> and
C<\u2029> for JavaScript compatibility. [%
see('no_javascript_safe')%].

This escaping is necessary for JavaScript because of a clash between
the JSON standard and the JavaScript (ECMAScript) standard. The
characters U+2028 ("LINE SEPARATOR" in the Unicode standard) and
U+2029 ("PARAGRAPH SEPARATOR" in the Unicode standard) are valid
within JSON, as defined by L</RFC 7159>, but invalid within JavaScript
strings, as defined by the ECMA standard (See ECMA Standard ECMA-262,
"ECMAScript Language Specification", 3rd Edition, section 7.3 "Line
Terminators").

=head4 Other escapes

The forward slash, /, known as "solidus" in the JSON specification,
does not have to be escaped, and JSON::Create's default is not to
escape it. [% see('escape_slash') %].

Other Unicode values are not escaped.  [% see('unicode_escape_all')
%].

=head3 Integers

Integers are printed in the usual way. Perl may interpret an integer
with a very large absolute value to be a floating point number, and
this module will print it out as such. See also L</Context-dependent
variables> for the handling of variables with both string and integer
values.

=head3 Floating point numbers

Finite floating point numbers are printed using printf formatting via
C<"%g">, like

    printf ("%g", $number);

[% see('set_fformat') %]

JSON does not allow NaN or infinity as bare values. From page 6 of
L</RFC 7159>:

=over

Numeric values that cannot be represented in the grammar below (such
as Infinity and NaN) are not permitted.

=back

L</create_json> converts NaN (not a number) values to
C<"nan"> (the letters C<nan> surrounded by double quotes), and
positive and negative infinity to C<"inf"> and C<"-inf">
respectively.

L</create_json_strict> disallows non-finite numbers. If a non-finite
number appears within its input, it prints a warning L</Non-finite
number in input> and returns the undefined value:

[% example('strict-non-finite') %]

A JSON::Create object created with L</new> converts in the same way as
L</create_json>.  [% see('non_finite_handler') %]. If L</strict> is
specified, non-finite numbers are passed to L</non_finite_handler> if
it is set, and if not, it prints a warning L</Non-finite number in
input> and returns the undefined value.

=head3 The undefined value

Undefined values in the input are mapped to the JSON literal "null".

[% example('undef') %]

=head3 Booleans

Booleans (C<true> and C<false>) from input via JSON::Parse version
0.37 or later will be turned into the outputs C<true> and
C<false>:

[% example('json-parse-bool') %]

Other kinds of object can be converted to booleans using the method
L</bool> (see below).

=head3 Context-dependent variables

A context-dependent variable is a variable which may contain a string
and a numerical value. Usually the string value is just a
representation of the number, but it may not be. The behaviour in the
case of a context-dependent variable is as follows.

If the variable contains a valid numerical value, the numerical value
is used in the output JSON, rather than the string value. However,
some modules, like L<Unicode::UCD/charinfo>, return context-dependent
hash values which have a non-number-like string under the key
C<script> with values such as C<Latin> or C<Common> but no valid
numerical value, despite being marked as context-dependent
variables. In such cases, the string value is used. (In terms of XS,
if the scalar is marked as C<SVt_PVIV> or C<SVt_PVNV>, the scalar is
tested with C<SvIOK> or C<SvNOK> respectively, and if this is true the
numerical value is used, if false the string value is used.)

Up to version 0.25, this module wrongly assumed that the string part
of a context-dependent variable would always be a valid representation
of a number, and the string was added to the output without quote
marks. In version 0.26, checking was done to see if the string
actually was a number. In version 0.27 this approach was abandoned and
the numerical value was given precedence. In version 0.28 this was
again altered for the sake of unusual cases like the C<script> key
returned by L<Unicode::UCD/charinfo>, where the scalar is marked as
having a numerical value but does not in fact contain a valid
numerical value.

=head2 Other types

JSON::Create is meant to provide serialization of data types. It does
not provide built-in serialization of Perl objects and other non-data
types, such as code references or regular expressions, beyond a few
basic defaults. How to handle non-data types is left completely up to
users. These basic defaults, and how to set up more extensive
handling, are described in the following subsections.

=head3 Scalar references

L</create_json> dereferences scalar references, then treats them as
scalars in the way described in L</Scalars>. 

L</create_json_strict> rejects scalar references. Input containing a
scalar reference causes a warning L</Input's type cannot be serialized
to JSON> and the undefined value to be returned.

A JSON::Create object created with L</new> behaves as L</create_json>
unless the L</strict> option is specified. If the strict option is
specified, scalar references are passed through to L</type_handler> if
it is set, otherwise input containing a scalar reference causes a
warning L</Input's type cannot be serialized to JSON> and the
undefined value to be returned.

=head3 Objects

L</create_json> handles Perl objects as if non-object
types. In other words, unless you specify object handling, it breaks
encapsulation. 

L</create_json_strict> rejects input containing Perl objects. If the
input contains an object (a blessed reference), a warning L</Object
cannot be serialized to JSON> is printed and the undefined value
returned.

A JSON::Create object created with L</new> can handle specified types
of object with method L</obj>, or with a general object handler
supplied via L</obj_handler>. By default it behaves like
L</create_json>. If L</strict> is chosen, it rejects input containing
Perl objects unless the user sets a handler for them with L</obj> or
L</obj_handler>.

=head3 Code, regexes, and other references

A code or other reference (regexes, globs, etc.) in the input of
L</create_json> or L</create_json_strict> prints a warning L</Input's
type cannot be serialized to JSON> and causes the entire return value
to be the undefined value. [% see('type_handler') %].

=head1 METHODS

If you need to alter the format of the output from the defaults of
L</create_json> or L</create_json_strict>, create an object with
L</new> and then set preferences on that object before producing
output with L</run>.

=head2 new

    my $jc = JSON::Create->new ();

Create a new "JSON::Create" object. Use L</run> to generate JSON with
it.

=head2 run

    my $json = $jc->run ($input);

This does exactly the same thing as L</create_json>, unless the output
format associated with C<$jc> has been altered using L</Methods for
formatting the output>. The return value is the output JSON.

=head2 fatal_errors

    $jc->fatal_errors (1);

If this is called with a true value, errors in the input are upgraded
from warnings to fatal errors.

[% example('fatal-errors') %]

[% since('0.10') %]


=head2 strict

    $jc->strict (1);

This switches on rejection of ambiguous inputs, which means

=over

=item * all non-data types, including objects,

=item * strings containing non-ASCII bytes (bytes with values of from 128 to 255) which are not marked as C<utf8> (character strings),

=item * non-finite floating point numbers (NaN or infinite values), and

=item * scalar references.

=back

Calling L</run> with such inputs results in a return value of C<undef>
(the undefined value) and a warning being printed. You can override
the behaviour for objects with L</obj>, L</obj_handler>, for non-data
types and scalar references with L</type_handler>, and for non-finite
numbers with L</non_finite_handler>.

The rejection of non-ASCII bytes in non-C<utf8> strings cannot be
overridden, so users need to ensure that all input is either
ASCII-only or character string-only (C<utf8>).

[% since('0.20') %]

=head2 Methods for formatting the output

These methods work on the object created with L</new> to format the
output JSON in a different way from the default when operating
L</run>. 

These methods do not affect the behaviour of L</create_json> or
L</create_json_strict>.

=head3 bool

    $jc->bool ('boolean');
    $jc->bool (qw/boolean JSON::Tiny::_Bool/);

Given a list of names of object types, the JSON::Create object, C<$jc>
in the example, will convert objects of these types into the JSON
literals C<true> or C<false> depending on whether Perl thinks they're
true or false. For example,

[% example('boolean') %]

If you prefer to take over all object handling yourself, there is also
L</obj_handler>, which overrides what is set with C<bool>.

=head4 Interoperability

The boolean values of the following Perl modules can interoperate with
JSON::Create. 

=over

=item L<boolean>

    $jc->bool ('boolean');

=item L<JSON::Tiny>

    $jc->bool ('JSON::Tiny::_Bool');

Round trip compatibility is also confirmed for JSON::Tiny version 0.54.

=item L<JSON::PP>

    $jc->bool ('JSON::PP::Boolean');

Round trip compatibility is also confirmed for JSON::PP version 2.27300.

=item L<Types::Serialiser>

    $jc->bool ('JSON::PP::Boolean');

B<Please note> the above is not a typo, L<JSON::PP::Boolean> is the
correct object type for Types::Serialiser. To confirm this, try

    print ref $Types::Serialiser::false;

=item L<Mojo::JSON>

    $jc->bool ('JSON::PP::Boolean', 'Mojo::JSON::_Bool');

Round trip compatibility is also confirmed for Mojo::JSON version 8.65.

The current version of Mojo::JSON (Mojolicious version 8.65) uses
C<JSON::PP::Boolean> for true and false values. Older versions used
their own type, C<Mojo::JSON::_Bool>.

JSON::Create's compatibility tests for Mojo::JSON compatibility are
available only in the git repository as F<xt/mojo-json.t>, rather than
in the CPAN release, because different versions of Mojolicious differ
a lot in not only function names but also variable names, as seen
above.

=back

You can handle multiple modules with the same object:

    $jc->bool (qw/boolean JSON::Tiny::_Bool JSON::PP::Boolean/);

The compatibility of the above modules can be confirmed by running the
test script F<t/bool.t> in the distribution. However, JSON::Create
does not install these modules, so unless you have installed them
yourself, the tests will just be skipped.

More modules will be added to this list as time permits.

=head3 downgrade_utf8

    $jc->downgrade_utf8 (1);

If this is set to a true value, the return value of L</create_json> or
L</run> is never upgraded to character strings, or C<utf8>. This
overrides the default behaviour, which is to upgrade the output to
C<utf8> if any part of the input is C<utf8>, or if the user has
requested replacement with L</replace_bad_utf8> and there are bad
characters in the user's input. See L</UNICODE HANDLING> for
details. All output of JSON::Create is valid UTF-8, regardless of what
this flag is set to. See L</Output is valid UTF-8>.

This method should be considered experimental.

[% since('0.18') %]

=head3 escape_slash

    $jc->escape_slash (1);

Call this with a true value to make the slash (known as the "solidus"
in the JSON specification) be escaped with a backslash. Call this with
any false value to make the slash not be escaped (the default
behaviour).

[% example('escape-slash') %]

See also L</Other escapes>.

[% since('0.07') %]

=head3 indent

   $jc->indent (1);

Add whitespace indentation to the output. The formula applied is to
add a newline plus indentation after each opening bracket, add the
same after each comma, and add the same before each closing
bracket. Tabs are used for all indentation. The number of tabs is
decided by the number of brackets open.

[% example('indent') %]

Users who prefer a different style of indentation should easily be
able to modify this output to their needs using simple substitutions,
for example C<s/^(\t+)/ "  " x length ($1) /gesm;> will convert from tabs
to two space indentation.

[% example('indent-format') %]

[% since('0.27') %]

=head3 no_javascript_safe

    $jc->no_javascript_safe (1);

If called with a true value, this switches off JavaScript protection
in the output JSON. If called with a false value, the JavaScript
protection is switched on again.

[% example('js-safe') %]

See also L</U+2028 and U+2029 (JavaScript clashes)>.

=head3 non_finite_handler

   $jc->non_finite_handler (\& handler);

This overrides the default behaviour for handling non-finite floating
point numbers, in other words NaN (not a number) and negative or
positive infinity, with a user-defined routine. The default behaviour
of this module is described at L</Floating point numbers>. 

The routine C<handler> is supplied with the non-finite number as its
sole argument, and returns one argument, the output JSON. For example,
to always use C<null> in place of the default, supply a function like
the following:

[% example('non-finite-handler') %]

[% handler_common('non_finite_handler') %]

[% since(0.17) %]

=head3 obj

    $jc->obj ('Zilog::Z80' => sub { my ($obj) = @_; print "\"Z80\""; });

Register JSON generators for Perl objects. When JSON::Create finds an
object with a registered type, it will call the method you have
supplied.

The argument to C<obj> is a hash. The keys are object names, and the
corresponding values are code references to the JSON serializer for
that object:

    $jc->obj (
        'My::Object' => \& object_to_json,
    );

The output is passed through to the output string unaltered. To have
your JSON output checked for validity, use the L</validate> option.

The function is called with the object reference as its only
argument, as if called like this:

    my $user_json = $my_object->object_to_json ();

The return value of the function, C<object_to_json> in the above
example, must be a single value, a string containing the object's JSON
encoding.

[% example('zilog') %]

The function is called "in scalar context", so

[% example('too-many-values') %]

If you need to pass or return more than a single argument, use a
closure:

[% example('closure') %]

Exceptions (fatal errors) are not caught by JSON::Create, so if you
want to halt the execution of JSON::Create, you can throw an exception
within your callback.

[% example('exception') %]

If you prefer to take over all object handling yourself, there is also
L</obj_handler>.

[% handler_undef %]

=head3 obj_handler

    $jc->obj_handler (\& my_obj_handler);

Supply an object handler. If you supply this, all objects will be
handled by your handler. For example, you can replace all objects with
'null' or die if an object is found.

[% handler_common('obj_handler') %]

Here is an example of handling various types of object with a
user-supplied handler:

[% example('obj-handler') %]

Here is an example of a "try harder" routine which does something like
the L<JSON> module does, by looking for methods on all objects:

[% example('try-harder') %]

This C<obj_handler> overrides whatever you have set with L</bool> or
L</obj>. Currently, it does not print a warning about this. See
L</BUGS>. The routine you use to handle objects may be the same as the
routine you use to handle types. See L</type_handler>. For more
details about the callbacks, see L</obj>.

[% since('0.13') %]

=head3 replace_bad_utf8

    $jc->replace_bad_utf8 (1);

Replace invalid UTF-8 in the inputs with the Unicode replacement
character U+FFFD, rather than produce the warning or error L</Invalid
UTF-8>. 

If C<replace_bad_utf8> is used on input containing only strings not
marked as character strings, and bad UTF-8 is found, JSON::Create
marks the output as a character string. Otherwise the replacement
character itself is just a series of broken bytes. [%
see('downgrade_utf8') %].

[% since(0.12) %]

=head3 set_fformat

    $jc->set_fformat ('%e');

This sets the printf-style format string used to print floating point
numbers. This is validated and a warning printed if the format cannot
be used. The format is also restricted to a maximum length to prevent
buffer overflows within the module.

[% example('set-fformat') %]

[% since('0.07') %]

=head3 type_handler

    $jc->type_handler (sub {return 'null'});

By default, when JSON::Create encounters a variable of a type which it
doesn't know what to do with, such as a glob or code reference, it
prints a warning and returns an undefined value. See L</Code, regexes,
and other references>.  The method C<type_handler> sets up a callback
which is called when a variable of an unhandled type is found in the
input. For example, to put the JSON literal C<null> in the output when
a reference to a variable of an unhandled type is encountered, rather
than print an error, the above example will do it.

[% handler_common('type_handler') %]

The following example shows a few possibilities for handling types:

[% example('type-handler') %]

If the L</strict> option is chosen, this method is also passed scalar
references.

[% example('type-handler-scalar') %]

[% since('0.10') %]

=head3 unicode_escape_all

    $jc->unicode_escape_all (1);

Call this with a true value to make all Unicode characters be escaped
into the C<\u3000> format. A false value switches that off again.

For example,

[% example('escape-all') %]

Note that JSON::Create contains its own UTF-8 validation, and this
escaping is applied regardless of whether Perl marks the bytes as
"utf8" or not:

[% example('escape-all-no-utf8') %]

See also L</Input strings must be UTF-8>.

=head3 unicode_upper

    $jc->unicode_upper (1);

Call this with a true value to make Unicode escapes use upper case
letters in the hexadecimal. See the example under
L</unicode_escape_all>.

=head3 validate

    $jc->validate (1);

If this is called with a true value, JSON::Create validates the
user-generated JSON given by the callbacks registered with L</obj>,
L</type_handler>, L</obj_handler> and L</non_finite_handler>. The
validation is done via the routine C<assert_valid_json> of
L<JSON::Parse>, so that module must be installed, otherwise the call
to C<validate> will fail. This also validates that the return value
contains only valid UTF-8.

If JSON::Parse is installed, and the JSON fails to validate, a warning
will be produced containing the invalid JSON string and the error
produced by C<assert_valid_json>, and the return value will be
undefined.

[% since('0.07') %]

=head1 EXPORTS

The module exports nothing except by request. Two functions,
L</create_json> and L</create_json_strict>, are exported on
request. There is also an export tag C<all> if you require both
functions:

    use JSON::Create ':all';

=head1 INSTALLATION

The module uses C internally, so you need a C compiler to install
it. If the compiled library cannot be loaded, there is also a backup
"pure Perl" module JSON::Create::PP in the distribution.

=head1 UNICODE HANDLING

This section details JSON::Create's handling of Unicode within
strings. This involves the distinction between two things with
confusingly similar names, Perl character strings, C<utf8>, and the
Unicode encoding C<UTF-8>.

=over

=item UTF-8 only

JSON::Create only consumes and produces the UTF-8 encoding of
Unicode. If you need a different encoding, please use the L<Encode>
module to encode the output.

=item Input strings must be UTF-8

All strings within the input must be UTF-8 encoded. This does not mean
that the strings must be Perl character strings (Perl's C<utf8>), it
means that input strings must be valid UTF-8. Input strings can be
either Perl character strings or bytes, but in either case the bytes
of the string must be valid UTF-8.

To illustrate this, examine the following example:

[% example('valid-chars') %]

The point here is that the UTF-8 validation is carried out regardless
of whether Perl thinks that the input string is "utf8". The string in
the third call to L</create_json> is not marked as utf8 by Perl but
still fails as invalid UTF-8.

JSON::Create's insistence on UTF-8 within input strings is related to
L</Unicode upgrades are not done according to Perl conventions>.

=item Output is valid UTF-8

All of the output of either the function L</create_json> or the method
L</run> is valid UTF-8. This does not mean that output strings are
marked as Perl character strings (C<utf8>), it means that the output
has been validated as UTF-8. 

There is one exception to this. In the case of user-generated JSON
returned by L</obj>, L</obj_handler>, L</type_handler> and
L</non_finite_handler>, the parts of the output consisting of return
values from user routines may be non-UTF-8-compliant if the user has
not switched on validation with L</validate>, and there are no
character strings (C<utf8>) anywhere in the input. However, if there
are any Perl character strings (C<utf8>) anywhere in the input, and
the user has not chosen L</downgrade_utf8>, JSON::Create validates the
entire output as UTF-8, as described in L</UTF-8 validation of
user-supplied JSON>.

=item Unicode upgrades are not done according to Perl conventions

If a single string anywhere in the input is a Perl character string,
in other words marked as C<utf8>, the entire output string is marked
as a Perl character string, C<utf8>, without altering the non-C<utf8>
bytes. This is at odds with Perl conventions. Perl says that
non-C<utf8> strings actually consist of characters with symbols from 0
to 255 which "coincidentally" fit into one byte, and C<utf8> strings
actually consist of characters with values from 0 to 0x10FFFF, not
bytes, and when combining the two, it is illegal to treat either of
these as bytes, but instead they must both be treated as numbers. To
illustrate this, here is the behaviour of L<JSON> contrasted with
JSON::Create:

[% example('json-unicode') %]

The Perl convention is that if a non-utf8 string and a utf8 string are
combined, they should be combined as L<JSON> does it, by treating each
byte of the non-utf8 string as if it is a single Unicode code point,
and writing equivalent UTF-8 bytes for that code point into the
output. JSON::Create does a different thing, which is to insist that
all input strings must be valid UTF-8, and after validating them, it
combines them with the C<utf8> strings without altering their
contents. This break with the Perl convention is by design.

This example illustrates what happens with non-UTF-8 bytes:

[% example('json-unicode-gzip-bytes') %]

=item Using replace_bad_utf8 may cause a utf8 upgrade

Please see the discussion under L</replace_bad_utf8>.

=item UTF-8 validation of user-supplied JSON

If you supply JSON via a user routine such as L</obj_handler>, and you
choose not to validate your output with L</validate>, and the input
contains a character string (C<utf8>), and you do not choose
L</downgrade_utf8>, the entire output string has to be validated as
UTF-8, to prevent a loophole where a string containing non-UTF-8
compliant bytes could get upgraded to a character string (C<utf8>).

In this case, if invalid UTF-8 is detected, the diagnostic L</Invalid
UTF-8 from user routine> is printed, and the undefined value
returned. Since the check is applied to the final output JSON, there
is no information about which routine was at fault, so to get a more
specific diagnosis, please switch on L</validate>.

Here is an example of how this may occur:

[% example('user-bad-utf8') %]

=back

=head1 DIAGNOSTICS

All diagnostics are warnings by default. [% see('fatal_errors') %].

=over

=item Input's type cannot be serialized to JSON

(Warning) A reference type such as a code reference, regexp, or glob
was found in the user's input. For a discussion, see L</Code, regexes,
and other references>. For how to overcome this, see L</type_handler>.

=item Invalid UTF-8

(Warning) Bytes in a Perl string were not valid UTF-8. [% see('replace_bad_utf8') %].

=item Invalid UTF-8 from user routine

(Warning) A return value from a user routine was not valid UTF-8. See
L</UTF-8 validation of user-supplied JSON>.

This diagnostic and the corresponding validation of user-supplied JSON
was added in version 0.19 of the module.

=item JSON::Parse::assert_valid_json failed

(Warning) The user requested validation with L</validate> and this failed.

=item Non-ASCII byte in non-utf8 string

(Warning) The user tried to encode a string containing a non-ASCII
byte in a non-C<utf8> string. This diagnostic occurs with either
L</create_json_strict> or L</strict>.

This diagnostic was added in version 0.20 of the module together with
L</create_json_strict> and the L</strict> method.

=item Non-finite number in input

(Warning) A number which cannot be represented as a floating point
number was found in the input. See L</Floating point numbers>.

This diagnostic was added in version 0.20 of the module together with
L</create_json_strict> and the L</strict> method.

=item Object cannot be serialized to JSON

(Warning) An object in the input could not be serialized to JSON. See
L</Objects> for a discussion.

This diagnostic was added in version 0.20 of the module together with
L</create_json_strict> and the L</strict> method.

=item Undefined value from user routine

(Warning) An undefined value was returned by a user routine set with
either L</obj>, L</obj_handler>, L</type_handler> or
L</non_finite_handler>. 

=back

=head1 PERFORMANCE

This module is fairly new on the scene, so speed is not a key issue
until the module is demonstrably producing correct outputs.

However, due to user interest, there is a benchmarking script in
F<bench/bench.pl> which compares the performance of the module with
L<JSON::XS> and L<Cpanel::JSON::XS>. Outputs look like this, where the
"improve" column is the improvement in speed of the fastest module
compared to the slowest:

[% INCLUDE "/home/ben/projects/json-create/bench/bench.output" | indent (4) %]

This only compares a few simple cases in which the output is
demonstrably correct. Also, at least on my computer, the numbers seem
to vary wildly from one test to another. The benchmarking script also
contains commented out code to test against L<JSON::DWIW> if you are
interested.

Please note that the numbers for the floating point results are at the
moment unfairly skewed in favour of JSON::Create, because whereas
JSON::XS prints out the full available precision of the number (which
is about equivalent to printing with a format C<%.15g>), JSON::Create
prints only six digits of precision, creating a false impression of
greater speed. Work on this is currently in progress.

=head1 BUGS

There is currently no facility to add whitespace to the output JSON.

There is currently no way to delete object handlers set via L</obj>
from a JSON::Create object.

There are a few remaining undecided issues around the default object
serialization.

No warning is printed when the user uses clashing methods like
L</bool> and L</obj_handler>.

Features added since version 0.16 of the module are not yet
implemented in JSON::Create::PP.

There is a bug in JSON::Create::PP's handling of non-integer numbers.

The floating point printing loses precision on round trips.

=head1 HISTORY

L</set_fformat> was added in version 0.07.

L</validate> was added in version 0.07.

L</fatal_errors> was added in version 0.10.

L</replace_bad_utf8> was added in version 0.12.

L</obj_handler> was added in version 0.13. This version also added
loading of the Pure-Perl version of the module, L<JSON::Create::PP>,
if the loading of JSON::Create failed.

L</non_finite_handler> was added in version 0.17.

L</downgrade_utf8> was added in version 0.18.

The L</Invalid UTF-8 from user routine> diagnostic was added in
version 0.19.

The L</create_json_strict> function and L</strict> methods and
associated diagnostics were added in version 0.20.

Indentation was added for objects with L</indent> in version 0.27.

Version 0.28 altered the handling of context-dependent variables to
use the numerical part as a JSON number if valid, and the string part
as a JSON string if not a valid number. See L</Context-dependent
variables> for all the details.

=head1 SEE ALSO

=over

=item RFC 7159

JSON is specified in L<RFC 7159 "The application/json Media Type for
JavaScript Object Notation
(JSON)"|http://www.ietf.org/rfc/rfc7159.txt>.

=item json.org

L<http://json.org> is the website for JSON, authored by Douglas
Crockford.

=item JSON::Parse

JSON::Create is a companion module to the same author's
L<JSON::Parse>. Please see that module's documentation for a summary
of JSON modules on CPAN (under "SEE ALSO").

=item L<JSON::Create::PP>

This is a backup module for JSON::Create in pure Perl.

=back

=head2 Blog posts

There are some blog posts about the JSON::Create internals of interest
to Perl XS programmers here:

=over

=item L<The mysterious case of the SVt_PVIV|http://blogs.perl.org/users/ben_bullock/2020/11/the-mysterious-case-of-the-svt-pviv.html>

=item L<JSON::Create now features indentation|http://blogs.perl.org/users/ben_bullock/2020/11/jsoncreate-now-features-indentation.html>

=item L<av_fetch can return NULL|http://blogs.perl.org/users/ben_bullock/2020/02/av-fetch-can-return-null.html>

=back

[% INCLUDE "author" %]

=cut

